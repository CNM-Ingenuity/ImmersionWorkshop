{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blockchain Immersion Workshop Welcome! This two-day workshop combines lecture and hands-on labs to teach you the foundamentals of blockchain for business. On Day 1, we focus on blockchain 101, blockchain use cases, and the open source framework called Hyperledger Fabric that powers blockchain for business. On Day 2, you will learn about the IBM-specific offerings that leverage Hyperledger Fabric, and how our unique combination of expertise, governance and operations tooling, and infrastructure capabilities can help you achieve business results faster and more securely. Agenda Day 1 Blockchain Explained Vehicle Lifecycle Demo Blockchain Use Cases Hyperledger Fabric Lab Lunch / Informal use case discussions Blockchain Explored Part 1 VSCode Lab Day 2 Blockchain Explored Part 2 IBM Blockchain Platform Next Steps Lunch Introduction to IBM Cloud Private and Kubernetes IBM Blockchain Platform for IBM Cloud Private Lab Acknowledgements Latrell Freeman for providing us with the backbone automation scripts Dave Wakeman for providing guidance on using MkDocs to make this Github Pages site Thanks to the following people who helped us test out the labs: Steven Bodie, Kevin Breitenother, Victoria Coates, Jack Sykes, MacKenna Kelleher, Keziah Knopp, Jasmine Burgess Contacts Austin Grice Barry Silliman Garrett Woodworth Jin VanStee","title":"Home"},{"location":"#blockchain-immersion-workshop","text":"Welcome! This two-day workshop combines lecture and hands-on labs to teach you the foundamentals of blockchain for business. On Day 1, we focus on blockchain 101, blockchain use cases, and the open source framework called Hyperledger Fabric that powers blockchain for business. On Day 2, you will learn about the IBM-specific offerings that leverage Hyperledger Fabric, and how our unique combination of expertise, governance and operations tooling, and infrastructure capabilities can help you achieve business results faster and more securely.","title":"Blockchain Immersion Workshop"},{"location":"#agenda","text":"","title":"Agenda"},{"location":"#day-1","text":"Blockchain Explained Vehicle Lifecycle Demo Blockchain Use Cases Hyperledger Fabric Lab Lunch / Informal use case discussions Blockchain Explored Part 1 VSCode Lab","title":"Day 1"},{"location":"#day-2","text":"Blockchain Explored Part 2 IBM Blockchain Platform Next Steps Lunch Introduction to IBM Cloud Private and Kubernetes IBM Blockchain Platform for IBM Cloud Private Lab","title":"Day 2"},{"location":"#acknowledgements","text":"Latrell Freeman for providing us with the backbone automation scripts Dave Wakeman for providing guidance on using MkDocs to make this Github Pages site Thanks to the following people who helped us test out the labs: Steven Bodie, Kevin Breitenother, Victoria Coates, Jack Sykes, MacKenna Kelleher, Keziah Knopp, Jasmine Burgess","title":"Acknowledgements"},{"location":"#contacts","text":"Austin Grice Barry Silliman Garrett Woodworth Jin VanStee","title":"Contacts"},{"location":"connect-home/","text":"Welcome to Marbles Connect-a-thon with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP) The goal of the lab is to give you hands on experience interacting with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP). You will take on the role of an organization that is part of a larger Hyperledger Fabric blockchain consortium called the Marbles business network. This lab is broken into two parts. In the first part, you will interact with your deployed peer, and enable the Marbles front end application to connect to the marbles chaincode installed on your peer. In the second part, you will go through the process of enabling the Marbles application to deploy inside a Kubernetes cluster. You will be able to transact marbles with the other lab participants who are all acting as their own organizations in the Marbles business network. Note This lab runs on Linux on IBM Z images and connects to an IBM Cloud Private cluster. Both environments run on IBM Z systems in the IBM Washington Systems Center (WSC). In order to connect to this environment, you must be VPN'ed into the WSC network. Open your CISCO AnyConnect client and point to: ssl.wsc.ihost.com . You will be given IDs and passwords at the beginning of the lab. Tip If you find any typos, errors, or just want to provide helpful feedback to make this lab better, please click on the GitHub icon in the lower left corner of this page to create an issue in the repository. Thanks for your feedback!","title":"Introduction"},{"location":"connect-home/#welcome-to-marbles-connect-a-thon-with-ibm-blockchain-platform-for-ibm-cloud-private-ibp4icp","text":"The goal of the lab is to give you hands on experience interacting with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP). You will take on the role of an organization that is part of a larger Hyperledger Fabric blockchain consortium called the Marbles business network. This lab is broken into two parts. In the first part, you will interact with your deployed peer, and enable the Marbles front end application to connect to the marbles chaincode installed on your peer. In the second part, you will go through the process of enabling the Marbles application to deploy inside a Kubernetes cluster. You will be able to transact marbles with the other lab participants who are all acting as their own organizations in the Marbles business network. Note This lab runs on Linux on IBM Z images and connects to an IBM Cloud Private cluster. Both environments run on IBM Z systems in the IBM Washington Systems Center (WSC). In order to connect to this environment, you must be VPN'ed into the WSC network. Open your CISCO AnyConnect client and point to: ssl.wsc.ihost.com . You will be given IDs and passwords at the beginning of the lab. Tip If you find any typos, errors, or just want to provide helpful feedback to make this lab better, please click on the GitHub icon in the lower left corner of this page to create an issue in the repository. Thanks for your feedback!","title":"Welcome to Marbles Connect-a-thon with IBM Blockchain Platform for IBM Cloud Private (IBP4ICP)"},{"location":"connect-part1/","text":"Overview The goal of this part of the lab is to go through the process of using your peer with the fabric command line interface (cli) tools and connecting it with marbles. In this part of the lab, you will: Connect to your peer Log in to our Kubernetes cluster Take a look at your peer setup environment variables Check the chaincode on the peer and the channel Submit transactions with your peer to create yourself as a marbles owner with a marble Configure the marbles application to connect to your peer Connect the marbles application to your peer Connect to your peer An IBM Blockchain Platform network has been set up with an organization for each member of the lab in our IBM Cloud Private Kubernetes Cluster. The necessary certificate material and environment variables to operate your peer as well as the marbles project have been packaged into a container for your use during the lab. This container is labeled based on your team. Please open a terminal window on your computer and set your given ip address and ssh into that z machine IP_ADDRESS=givenip ssh bcuser@$IP_ADDRESS Sample Output: Welcome to Ubuntu 16.04.5 LTS (GNU/Linux 4.4.0-139-generic s390x) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage Last login: Mon Jan 21 21:43:38 2019 from 192.168.22.64 bcuser@ubuntu16045:~ Then, add the cluster to your /etc/hosts and add the self-signed certificate to your ca-certificates echo 192.168.22.81 wsc-ibp-icp-cluster.icp | sudo tee --append /etc/hosts sudo mkdir /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp sudo openssl s_client -showcerts -servername wsc-ibp-icp-cluster.icp -connect wsc-ibp-icp-cluster.icp:8443 /dev/null 2 /dev/null | sudo openssl x509 | sudo tee /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp/ca.crt sudo update-ca-certificates Sample Output: 192.168.22.81 wsc-ibp-icp-cluster.icp -----BEGIN CERTIFICATE----- MIIFfjCCA2agAwIBAgIQbJlENedx5PvDbGD7XLDnITANBgkqhkiG9w0BAQsFADBj MQswCQYDVQQGEwJVUzERMA8GA1UECAwITmV3IFlvcmsxDzANBgNVBAcMBkFybW9u azEaMBgGA1UECgwRSUJNIENsb3VkIFByaXZhdGUxFDASBgNVBAMMC3d3dy5pYm0u Y29tMCAXDTE4MTIxMjE5NTQ1MVoYDzIxMTgxMTE4MTk1NDUxWjBgMQswCQYDVQQG EwJDTjEQMA4GA1UECAwHU2hhYW54aTEOMAwGA1UEBwwFWGknYW4xGjAYBgNVBAoM EUlCTSBDbG91ZCBQcml2YXRlMRMwEQYDVQQDDAppY3Atcm91dGVyMIIBIjANBgkq hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArsBisMJEyMGHZ+93mcFsXX0AQc+QXSVW o53f3JEd2Kn+tZLx57vOzRWmMop7B1pSe06c1GwFKofOWSTgHCHv8DO8+h9TIm3x +9IUaLx65mxrTMToUjIxjNyt2JjElHJskxrbpwJsofG59gxhGal8ed89SveXYIL/ PkXvkm5jsoPaRFjgQq0KJoy9UO26aD/FMJu9HzV+7P6Tu8Q+OJHgWSvIgKfX9vOg qyMxv8vGYEGh4jLgQFRMMfXdH01y2diZ259771wHjsTdMRUnxRC36RTDgIXp+0CR 143p1+dmucYD5G45rOwzPuDi67VNho8mtXs5ohTQfovj4FdcDVtFgQIDAQABo4IB LTCCASkwCQYDVR0TBAIwADAdBgNVHQ4EFgQUIMoa55D0BPmJ5FYOEiIa6mw+qtYw gZUGA1UdIwSBjTCBioAUZ9zE9CrhJ2Lm/tLiDLDK5H3asjqhZ6RlMGMxCzAJBgNV BAYTAlVTMREwDwYDVQQIDAhOZXcgWW9yazEPMA0GA1UEBwwGQXJtb25rMRowGAYD VQQKDBFJQk0gQ2xvdWQgUHJpdmF0ZTEUMBIGA1UEAwwLd3d3LmlibS5jb22CCQCV Y/GaGOxNzTAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwCwYDVR0PBAQD AgWgMDkGA1UdEQQyMDCHBH8AAAGCCWxvY2FsaG9zdIcEwKgWUYIXd3NjLWlicC1p Y3AtY2x1c3Rlci5pY3AwDQYJKoZIhvcNAQELBQADggIBABCkUfS8TTO2sPJlJjAn ZiatcrliKZ2KJqdNNouF68E+xHfthfXxhl93TP5oUEw7lFN8yRb+z0o16wZksliw h8FpunHZAuQ+M2qI3afIiRU2H58drGHkBmbZwoMYAQaFrU+A9VEzgibtjBHCkL4p g+3kzQySCJq+A9lmVq/gwrd3cqfPxsFckqq1eGvP8BfcwxvkUIPnOp/Vh9f2jgK7 UNfmPd4hZSzTr2jOfdBAGaltc4C+MAougCAppz7cVQXvb9A2b7ffF3JmYbr626Bk Pp7c0rZAzLRsoZy8ngT9zS+9CucY8MolpPDQmBL48asaMYCRgTx6wAgD6bDzJnpt F0c+FFf7k4782vJELs4gwXkkWRVmaHBlHn4yfYObsiS23snhu2Fvuu2bBWmFMXEr PCK9d1JO1czb672fd18aOj6pmNLZMiIfwIxOxkDpASa4urOhA4sV/61cTpxCSuGs MFhrLN9rKvPlQCh+z/gLPvcf/DVuKoRO+JIVLKl7oSp4GQY7HjdpzggUvCxayp3J EUe4eqOnN50oogTFw8FA4/mNrMzt4wXfk/1yPgWS9ey0EBuFg8fTi2GjLuR00Xsb pjbmU0n0RUpzWdZBHZwb2SpvA6D5M7Ii+aFM0eH5YK5gCU9U9x3hI1MjAtVsINsF cTiYtc/9hu704vR7CQ3uFvOk -----END CERTIFICATE----- Updating certificates in /etc/ssl/certs... 1 added, 0 removed; done. Running hooks in /etc/ca-certificates/update.d... done. Take particular note that 1 certificate was added and 0 removed in your output like in the sample output above. Next, set your team name and login to the private docker repository TEAM=teamxx credential=p@ssw0rd echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $TEAM --password-stdin Sample Output: Login Succeeded Now, start your unique image which will return a command prompt: docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash This command is using Docker to run your team's container in an interactive bash shell and connect it to your machine's docker socket so you can create sibling containers from your container image. Additionally, you are giving it the name of your team and forwarding traffic on port 3000 of the host to port 3001 on your container to access your marbles application during the lab. Login to our Kubernetes cluster Run the following command to connect to the running IBM Cloud Private Kubernetes cluster. cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Take a look at your peer setup environment variables In order to operate your peer a number of environment variables need to be set. Let's take a look at some of the environment variables set for the Hyperledger Fabric cli to work with your peer: env | grep CORE Sample Output: CORE_PEER_LOCALMSPID=org0 CORE_PEER_TLS_ENABLED=true CORE_PEER_MSPCONFIGPATH=/home/org0/admin CORE_PEER_TLS_ROOTCERT_FILE=/home/org0/peertls.pem CORE_PEER_ADDRESS=192.168.22.81:30035 CORE_PEER_LOCALMSPID=org0 defines the local MSP or Membership Services Provider of the peer which contains the identifying information (i.e., certs and keys) for the peer as well as the certificates of trusted Certificate Authorities which are authorized to issue identities on behalf of the organization. (In this example org0 is the MSPID, yours will correspond with your team) CORE_PEER_TLS_ENABLED=true is used to enable transport layer security (TLS) communication. CORE_PEER_MSPCONFIGPATH points to the MSP material you are using to operate the peer CORE_PEER_TLS_ROOTCERT_FILE is the root TLS certificate for the peer which your system needs to trust to have a TLS connection with the peer. CORE_PEER_ADDRESS is the peer's IP address used to connect with the peer. Check the chaincode on the peer and the channel In order to check which chaincode is installed on your peer run: peer chaincode list --installed Sample Output: Get installed chaincodes on peer: Name: marbles, Version: 1.0, Path: marbles, Id: 4421fd51a7949b08620ab8db7407d1269c38e4ef2edd143b1a78d56ae82eaa2d You will notice the marbles chaincode has been installed on your peer. Next, let's check which chaincode is instantiated on the channel: peer chaincode list --instantiated -C $CHANNEL Sample Output: Get instantiated chaincodes on channel mychannel: Name: marbles, Version: 1.0, Path: marbles, Escc: escc, Vscc: vscc Here, you see the marbles chaincode has also been instantiated on the channel and is ready to be used to submit transactions. Submit transactions with the peer to create yourself as a marbles owner with a marble of your own Now it's time for one of your team members to add yourself as a marbles owner to the channel. First set your name as the marbles owner owner=Garrett Then create the owner with the following command: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_owner , o0'$team' , '$owner' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-08 03:47:55.093 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Next, give your owner a black marble: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_marble , m0'$team' , black , 200 , o0'$team' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output 2019-03-08 03:48:02.027 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Finally, run a query against the ledger to see your owner and marble as well as everyone else's so far: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ read_everything ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-15 08:47:04.730 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 payload: {\\ owners\\ :[{\\ docType\\ :\\ marble_owner\\ ,\\ id\\ :\\ o015525575491703BpSw\\ ,\\ username\\ :\\ rick\\ ,\\ company\\ :\\ org0\\ ,\\ enabled\\ :true} Note: This will grow as more marbles and owners get added to the ledger by your org and other orgs. Configure the marbles application to connect to your peer Go into the marbles directory: cd marbles/config The marbles application will connect to your fabric network using the Hyperledger Fabric Node.js Software Development Kit (SDK) Application Programming Interface (API) by consuming information in the file connection_profile_tls.json Take a look at this file with cat connection_profile_tls.json Take note that this file has connection information and TLS certificates for your, peers, certificate authority (CA), and the orderer for your network. Next, you will be able to specify which users you want to enroll in your application. Edit the file marbles_tls.json to do this: vim marbles_tls.json Edit the names to what you want in the usernames section such as: { cred_filename : connection_profile_tls.json , use_events : true, keep_alive_secs : 120, usernames : [ Beth , Rick , Jerry ], port : 3001 } In vim you edit by typing i and then making your changes using the arrow keys to navigate. Once you are finished making changes hit the escape key. Then save your changes with a save command such as :x , holding down shift and typing ZZ ( shift + ZZ ), shift + ZQ or using the worst option :wq . Once the file has been saved, move back to the parent directory with cd .. Connect the marbles application to your peer Run npm install -g gulp This will install the gulp npm package necessary to run the marbles application. Run npm install This will install the dependencies for the marbles application specified in the package.json file in the /home/marbles directory. This may take a few minutes. You will notice a bunch of CXX(target) in the output of this command because two of the packages (i.e., pkcs11js and grpc) needs to be compiled from source for s390x. This needs to happen since the binaries are not publicly available for this platform. When this command completes it will return your terminal to you. Now you can start the marbles application with gulp marbles_tls Open up a web browser on your pc and navigate to the ip given to you earlier at port 3000 in the form xxx.xxx.xxx.xxx:3000 where xxx.xxx.xxx.xxx is your given ip address with each x being a possible digit (e.g., 192.168.22.150:3000 ). First, choose Express to setup your marbles application Here you can see your org, the owners and marbles you created in the marbles_tls.json file and the marble and owner you created with the cli. You created a black marble with the cli and the application randomly selects a color for the marbles created from the marbles_tls.json file (in this case black, but your mileage with the random function may vary) We can also see the other orgs and their marbles that are connected in this connectathon. Next turn on story mode to see the marble transaction process: Click on settings Enable Story Mode Finally, trade some marbles to other users. Click on a marble from a user in your org and drag it to another user in your org Click and drag a marble from a member in your org and move it to a member of a different org Click and drag a marble from a member of a different org and drag it to a member of your org Notice that you can give marbles to other orgs but can't take them and think about why this may be the case... Now close the application by returning to your terminal and typing ctrl + c to return your terminal prompt. You have now setup the marbles application. Please move on to part 2 where you will deploy this into your cluster.","title":"Part 1"},{"location":"connect-part1/#overview","text":"The goal of this part of the lab is to go through the process of using your peer with the fabric command line interface (cli) tools and connecting it with marbles. In this part of the lab, you will: Connect to your peer Log in to our Kubernetes cluster Take a look at your peer setup environment variables Check the chaincode on the peer and the channel Submit transactions with your peer to create yourself as a marbles owner with a marble Configure the marbles application to connect to your peer Connect the marbles application to your peer","title":"Overview"},{"location":"connect-part1/#connect-to-your-peer","text":"An IBM Blockchain Platform network has been set up with an organization for each member of the lab in our IBM Cloud Private Kubernetes Cluster. The necessary certificate material and environment variables to operate your peer as well as the marbles project have been packaged into a container for your use during the lab. This container is labeled based on your team. Please open a terminal window on your computer and set your given ip address and ssh into that z machine IP_ADDRESS=givenip ssh bcuser@$IP_ADDRESS Sample Output: Welcome to Ubuntu 16.04.5 LTS (GNU/Linux 4.4.0-139-generic s390x) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage Last login: Mon Jan 21 21:43:38 2019 from 192.168.22.64 bcuser@ubuntu16045:~ Then, add the cluster to your /etc/hosts and add the self-signed certificate to your ca-certificates echo 192.168.22.81 wsc-ibp-icp-cluster.icp | sudo tee --append /etc/hosts sudo mkdir /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp sudo openssl s_client -showcerts -servername wsc-ibp-icp-cluster.icp -connect wsc-ibp-icp-cluster.icp:8443 /dev/null 2 /dev/null | sudo openssl x509 | sudo tee /usr/local/share/ca-certificates/wsc-ibp-icp-cluster.icp/ca.crt sudo update-ca-certificates Sample Output: 192.168.22.81 wsc-ibp-icp-cluster.icp -----BEGIN CERTIFICATE----- MIIFfjCCA2agAwIBAgIQbJlENedx5PvDbGD7XLDnITANBgkqhkiG9w0BAQsFADBj MQswCQYDVQQGEwJVUzERMA8GA1UECAwITmV3IFlvcmsxDzANBgNVBAcMBkFybW9u azEaMBgGA1UECgwRSUJNIENsb3VkIFByaXZhdGUxFDASBgNVBAMMC3d3dy5pYm0u Y29tMCAXDTE4MTIxMjE5NTQ1MVoYDzIxMTgxMTE4MTk1NDUxWjBgMQswCQYDVQQG EwJDTjEQMA4GA1UECAwHU2hhYW54aTEOMAwGA1UEBwwFWGknYW4xGjAYBgNVBAoM EUlCTSBDbG91ZCBQcml2YXRlMRMwEQYDVQQDDAppY3Atcm91dGVyMIIBIjANBgkq hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArsBisMJEyMGHZ+93mcFsXX0AQc+QXSVW o53f3JEd2Kn+tZLx57vOzRWmMop7B1pSe06c1GwFKofOWSTgHCHv8DO8+h9TIm3x +9IUaLx65mxrTMToUjIxjNyt2JjElHJskxrbpwJsofG59gxhGal8ed89SveXYIL/ PkXvkm5jsoPaRFjgQq0KJoy9UO26aD/FMJu9HzV+7P6Tu8Q+OJHgWSvIgKfX9vOg qyMxv8vGYEGh4jLgQFRMMfXdH01y2diZ259771wHjsTdMRUnxRC36RTDgIXp+0CR 143p1+dmucYD5G45rOwzPuDi67VNho8mtXs5ohTQfovj4FdcDVtFgQIDAQABo4IB LTCCASkwCQYDVR0TBAIwADAdBgNVHQ4EFgQUIMoa55D0BPmJ5FYOEiIa6mw+qtYw gZUGA1UdIwSBjTCBioAUZ9zE9CrhJ2Lm/tLiDLDK5H3asjqhZ6RlMGMxCzAJBgNV BAYTAlVTMREwDwYDVQQIDAhOZXcgWW9yazEPMA0GA1UEBwwGQXJtb25rMRowGAYD VQQKDBFJQk0gQ2xvdWQgUHJpdmF0ZTEUMBIGA1UEAwwLd3d3LmlibS5jb22CCQCV Y/GaGOxNzTAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwCwYDVR0PBAQD AgWgMDkGA1UdEQQyMDCHBH8AAAGCCWxvY2FsaG9zdIcEwKgWUYIXd3NjLWlicC1p Y3AtY2x1c3Rlci5pY3AwDQYJKoZIhvcNAQELBQADggIBABCkUfS8TTO2sPJlJjAn ZiatcrliKZ2KJqdNNouF68E+xHfthfXxhl93TP5oUEw7lFN8yRb+z0o16wZksliw h8FpunHZAuQ+M2qI3afIiRU2H58drGHkBmbZwoMYAQaFrU+A9VEzgibtjBHCkL4p g+3kzQySCJq+A9lmVq/gwrd3cqfPxsFckqq1eGvP8BfcwxvkUIPnOp/Vh9f2jgK7 UNfmPd4hZSzTr2jOfdBAGaltc4C+MAougCAppz7cVQXvb9A2b7ffF3JmYbr626Bk Pp7c0rZAzLRsoZy8ngT9zS+9CucY8MolpPDQmBL48asaMYCRgTx6wAgD6bDzJnpt F0c+FFf7k4782vJELs4gwXkkWRVmaHBlHn4yfYObsiS23snhu2Fvuu2bBWmFMXEr PCK9d1JO1czb672fd18aOj6pmNLZMiIfwIxOxkDpASa4urOhA4sV/61cTpxCSuGs MFhrLN9rKvPlQCh+z/gLPvcf/DVuKoRO+JIVLKl7oSp4GQY7HjdpzggUvCxayp3J EUe4eqOnN50oogTFw8FA4/mNrMzt4wXfk/1yPgWS9ey0EBuFg8fTi2GjLuR00Xsb pjbmU0n0RUpzWdZBHZwb2SpvA6D5M7Ii+aFM0eH5YK5gCU9U9x3hI1MjAtVsINsF cTiYtc/9hu704vR7CQ3uFvOk -----END CERTIFICATE----- Updating certificates in /etc/ssl/certs... 1 added, 0 removed; done. Running hooks in /etc/ca-certificates/update.d... done. Take particular note that 1 certificate was added and 0 removed in your output like in the sample output above. Next, set your team name and login to the private docker repository TEAM=teamxx credential=p@ssw0rd echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $TEAM --password-stdin Sample Output: Login Succeeded Now, start your unique image which will return a command prompt: docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash This command is using Docker to run your team's container in an interactive bash shell and connect it to your machine's docker socket so you can create sibling containers from your container image. Additionally, you are giving it the name of your team and forwarding traffic on port 3000 of the host to port 3001 on your container to access your marbles application during the lab.","title":"Connect to your peer"},{"location":"connect-part1/#login-to-our-kubernetes-cluster","text":"Run the following command to connect to the running IBM Cloud Private Kubernetes cluster. cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK","title":"Login to our Kubernetes cluster"},{"location":"connect-part1/#take-a-look-at-your-peer-setup-environment-variables","text":"In order to operate your peer a number of environment variables need to be set. Let's take a look at some of the environment variables set for the Hyperledger Fabric cli to work with your peer: env | grep CORE Sample Output: CORE_PEER_LOCALMSPID=org0 CORE_PEER_TLS_ENABLED=true CORE_PEER_MSPCONFIGPATH=/home/org0/admin CORE_PEER_TLS_ROOTCERT_FILE=/home/org0/peertls.pem CORE_PEER_ADDRESS=192.168.22.81:30035 CORE_PEER_LOCALMSPID=org0 defines the local MSP or Membership Services Provider of the peer which contains the identifying information (i.e., certs and keys) for the peer as well as the certificates of trusted Certificate Authorities which are authorized to issue identities on behalf of the organization. (In this example org0 is the MSPID, yours will correspond with your team) CORE_PEER_TLS_ENABLED=true is used to enable transport layer security (TLS) communication. CORE_PEER_MSPCONFIGPATH points to the MSP material you are using to operate the peer CORE_PEER_TLS_ROOTCERT_FILE is the root TLS certificate for the peer which your system needs to trust to have a TLS connection with the peer. CORE_PEER_ADDRESS is the peer's IP address used to connect with the peer.","title":"Take a look at your peer setup environment variables"},{"location":"connect-part1/#check-the-chaincode-on-the-peer-and-the-channel","text":"In order to check which chaincode is installed on your peer run: peer chaincode list --installed Sample Output: Get installed chaincodes on peer: Name: marbles, Version: 1.0, Path: marbles, Id: 4421fd51a7949b08620ab8db7407d1269c38e4ef2edd143b1a78d56ae82eaa2d You will notice the marbles chaincode has been installed on your peer. Next, let's check which chaincode is instantiated on the channel: peer chaincode list --instantiated -C $CHANNEL Sample Output: Get instantiated chaincodes on channel mychannel: Name: marbles, Version: 1.0, Path: marbles, Escc: escc, Vscc: vscc Here, you see the marbles chaincode has also been instantiated on the channel and is ready to be used to submit transactions.","title":"Check the chaincode on the peer and the channel"},{"location":"connect-part1/#submit-transactions-with-the-peer-to-create-yourself-as-a-marbles-owner-with-a-marble-of-your-own","text":"Now it's time for one of your team members to add yourself as a marbles owner to the channel. First set your name as the marbles owner owner=Garrett Then create the owner with the following command: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_owner , o0'$team' , '$owner' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-08 03:47:55.093 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Next, give your owner a black marble: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ init_marble , m0'$team' , black , 200 , o0'$team' , '$CORE_PEER_LOCALMSPID' ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output 2019-03-08 03:48:02.027 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 Finally, run a query against the ledger to see your owner and marble as well as everyone else's so far: peer chaincode invoke -C ${CHANNEL} -n ${CC_NAME} -c '{ Args :[ read_everything ]}' --tls --cafile $ORDERER_CA -o ${ORDERER_1} Sample Output: 2019-03-15 08:47:04.730 UTC [chaincodeCmd] chaincodeInvokeOrQuery - INFO 001 Chaincode invoke successful. result: status:200 payload: {\\ owners\\ :[{\\ docType\\ :\\ marble_owner\\ ,\\ id\\ :\\ o015525575491703BpSw\\ ,\\ username\\ :\\ rick\\ ,\\ company\\ :\\ org0\\ ,\\ enabled\\ :true} Note: This will grow as more marbles and owners get added to the ledger by your org and other orgs.","title":"Submit transactions with the peer to create yourself as a marbles owner with a marble of your own"},{"location":"connect-part1/#configure-the-marbles-application-to-connect-to-your-peer","text":"Go into the marbles directory: cd marbles/config The marbles application will connect to your fabric network using the Hyperledger Fabric Node.js Software Development Kit (SDK) Application Programming Interface (API) by consuming information in the file connection_profile_tls.json Take a look at this file with cat connection_profile_tls.json Take note that this file has connection information and TLS certificates for your, peers, certificate authority (CA), and the orderer for your network. Next, you will be able to specify which users you want to enroll in your application. Edit the file marbles_tls.json to do this: vim marbles_tls.json Edit the names to what you want in the usernames section such as: { cred_filename : connection_profile_tls.json , use_events : true, keep_alive_secs : 120, usernames : [ Beth , Rick , Jerry ], port : 3001 } In vim you edit by typing i and then making your changes using the arrow keys to navigate. Once you are finished making changes hit the escape key. Then save your changes with a save command such as :x , holding down shift and typing ZZ ( shift + ZZ ), shift + ZQ or using the worst option :wq . Once the file has been saved, move back to the parent directory with cd ..","title":"Configure the marbles application to connect to your peer"},{"location":"connect-part1/#connect-the-marbles-application-to-your-peer","text":"Run npm install -g gulp This will install the gulp npm package necessary to run the marbles application. Run npm install This will install the dependencies for the marbles application specified in the package.json file in the /home/marbles directory. This may take a few minutes. You will notice a bunch of CXX(target) in the output of this command because two of the packages (i.e., pkcs11js and grpc) needs to be compiled from source for s390x. This needs to happen since the binaries are not publicly available for this platform. When this command completes it will return your terminal to you. Now you can start the marbles application with gulp marbles_tls Open up a web browser on your pc and navigate to the ip given to you earlier at port 3000 in the form xxx.xxx.xxx.xxx:3000 where xxx.xxx.xxx.xxx is your given ip address with each x being a possible digit (e.g., 192.168.22.150:3000 ). First, choose Express to setup your marbles application Here you can see your org, the owners and marbles you created in the marbles_tls.json file and the marble and owner you created with the cli. You created a black marble with the cli and the application randomly selects a color for the marbles created from the marbles_tls.json file (in this case black, but your mileage with the random function may vary) We can also see the other orgs and their marbles that are connected in this connectathon. Next turn on story mode to see the marble transaction process: Click on settings Enable Story Mode Finally, trade some marbles to other users. Click on a marble from a user in your org and drag it to another user in your org Click and drag a marble from a member in your org and move it to a member of a different org Click and drag a marble from a member of a different org and drag it to a member of your org Notice that you can give marbles to other orgs but can't take them and think about why this may be the case... Now close the application by returning to your terminal and typing ctrl + c to return your terminal prompt. You have now setup the marbles application. Please move on to part 2 where you will deploy this into your cluster.","title":"Connect the marbles application to your peer"},{"location":"connect-part2/","text":"Overview The goal of this part of the lab is to guide you through the process of packaging up a blockchain front end application to run inside a Kubernetes cluster. In the lab environment, this happens to be the same cluster that is hosting your blockchain components. In the real world, this may not always be the case. In this part of the lab, you will: Build a docker image with the Marbles UI Test the container locally on your Linux image Push the image to the ICP cluster's private docker registry Create a Kubernetes deployment and service for the Marbles UI Deploy the Kubernetes deployment Test the marbles UI Only if you stopped in between the lab parts 1 and 2 make sure you still have an ssh connection to your bcuser instance. If not please rerun IP_ADDRESS=givenip for your given ip and ssh bcuser@$IP_ADDRESS Check to make sure you are still in your docker image. If you got out of your docker image go back into the image by first setting your TEAM with TEAM=teamxx where xx is the number of your team. Then, check if your container is still running with docker ps | grep team a) If you get sample output showing a container such as: 6e6ad92499b1 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-team10:1.0 \"bash\" 12 minutes ago Up 12 minutes 0.0.0.0:3000- 3001/tcp team10 follow Option a) of step 3 below b) If you get sample output not showing anything such as: follow Option b) of step 3 below Do only 1 of the options below based on step 2 above! a) exec back into your running container with docker exec -it $TEAM sh OR b) restart your container with docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash Before you start, make sure you are still logged in to the cluster. Run the following commands to display the pods that are currently deployed to our cluster. First, type kubectl get pods Sample Output: NAME READY STATUS RESTARTS AGE connectathon-orderer-orderer-85bb44f87c-qk662 1/1 Running 0 1d connectathon-ordererorg-ca-fabric-ca-deployment-7f6b9b6577whxgr 1/1 Running 0 1d connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 1d connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 1d connectathon-org1-ca-fabric-ca-deployment-59f9457fc5-9jmfp 1/1 Running 0 1d connectathon-org10-ca-fabric-ca-deployment-76794dcbbf-jdkcr 1/1 Running 0 1d connectathon-org10peer1-86dc5fcdf7-6c5qm 2/2 Running 0 39m connectathon-org11-ca-fabric-ca-deployment-5bc55cc776-5cjbz 1/1 Running 0 1d connectathon-org11peer1-69f67d965-svwjh 2/2 Running 0 1d connectathon-org1peer1-7665b7c6d7-x8spx 2/2 Running 0 1d connectathon-org2-ca-fabric-ca-deployment-787cbdf766-qwdjw 1/1 Running 0 1d connectathon-org2peer1-7d4bbfc7bf-gs9qv 2/2 Running 0 1d connectathon-org3-ca-fabric-ca-deployment-54cfc78777-m782f 1/1 Running 0 1d If you are able to see the output of the kubectl command such as above you are still logged in. If not, run: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Now, run kubectl get pods | grep $CORE_PEER_LOCALMSPID Sample Output: NAME READY STATUS RESTARTS AGE connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 7h You should see one peer pod, and one CA pod. Both should be in Running status. Your organization only has one peer in this scenario. Build a docker image Now that you have tested the Marbles front end User Interface (Marbles UI, for short), let's save it as a docker image using the supplied Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Think of it as a specific way to package up a set of files and instructions that together make up a microservice. Go to your marbles directory: cd /home/marbles Here you should see a Dockerfile: ls -ltr Dockerfile Sample Output: -rw-rw-r-- 1 1000 1000 394 Feb 28 22:12 Dockerfile If you are curious, cat the file to look at its contents: cat Dockerfile Sample Output: FROM node:8-alpine ENV NPM_CONFIG_LOGLEVEL warn RUN mkdir -p /usr/src/app WORKDIR /usr/src/app COPY package.json /usr/src/app/ RUN apk add --no-cache --virtual .build-deps make gcc g++ python \\ npm install --silent \\ npm install gulp -g ---unsafe-perm \\ apk del .build-deps .build-deps make gcc g++ python COPY . /usr/src/app/ EXPOSE 3001 CMD [ gulp , marbles_tls ] The above Dockerfile builds from an Alpine node image already out there in DockerHub. This is a bare bones Linux image of the Alpine distribution with node version 8 installed. Next, the NPM_CONFIG_LOGLEVEL for npm is globally set to warn so that npm will only print errors and warnings. ENV is used for this to persist this change as an environment variable in your finished container. Then, it uses RUN to run a command inside of the base node:8-alpine container to make a directory for the marbles application. WORKDIR makes this directory the current working directory. Moreover, COPY brings the package.json file (containing the names of the application's dependent node modules) into the containers /usr/src/app directory. The following RUN command uses apk (Alpine's package manager) to install a variety of pre-reqs to your npm install such as make, gcc and python, before running the actual npm install twice to install both the necessary node modules needed by the Marbles UI itself and gulp to start the marbles UI. Note that this is all done in one line with to make it occur in one layer. This way, at the end of the RUN you can use a delete command apk del and take the developer tools you no longer need out of your image. If you instead ran this as multiple commands, you would not be able to shrink your image size since previous layers can't be effectively deleted due to the layered file system. Finally, you copy the application itself and the connection profile materials into your working directory, document the port you will run marbles on ( 3001 ), and set a command for the container to run when it starts gulp marbles_tls . Now let's run docker build in the /home/marbles directory: docker build -t marbles-$team . NOTE: Please remember to not forget that pesky . Otherwise you will get an error saying \"docker build\" requires exactly 1 argument Sample Output: Sending build context to Docker daemon 261.9MB Step 1/9 : FROM node:8-alpine --- 66f08ecb7600 Step 2/9 : ENV NPM_CONFIG_LOGLEVEL warn --- Using cache --- 180c28267c41 Step 3/9 : RUN mkdir -p /usr/src/app --- Using cache --- f9615b4a1813 Step 4/9 : WORKDIR /usr/src/app --- Using cache --- e53d507c2bf9 .... .... lots more messages .... Successfully built 9b57c7c3e480 Successfully tagged marbles-team00:latest Now you should see this new image that you just built: docker images Sample Output: Test the docker image locally Let's test the image that was just built, by running it locally: docker run -it --init -p 3001:3001/tcp --name marbles-$team marbles-$team Sample Output [20:57:50] Using gulpfile /usr/src/app/gulpfile.js [20:57:50] Starting 'env_tls'... [20:57:50] Finished 'env_tls' after 73 \u03bcs [20:57:50] Starting 'build-sass'... [20:57:50] Finished 'build-sass' after 7.48 ms [20:57:50] Starting 'watch-sass'... [20:57:50] Finished 'watch-sass' after 7.47 ms [20:57:50] Starting 'watch-server'... [20:57:50] Finished 'watch-server' after 2.55 ms [20:57:50] Starting 'server'... info: Checking connection profile is done info: Loaded config file /usr/src/app/config/marbles_tls.json info: Loaded connection profile file /usr/src/app/config/connection_profile_tls.json ... lots of output ... - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - debug: Detected that we have launched successfully before debug: Welcome back - Marbles is ready debug: Open your browser to http://localhost:3001 and login as admin - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - After you see the \"Open your browser to https://localhost:3001\" message, point your browser to the IP address of your Linux image, e.g., http://192.168.22.107:3001 and you will see the Marbles UI. Once you verify that the image works locally, it's time to stop the running container. Type Ctrl + C to exit out of the running container in the current terminal. Push image to the ICP Cluster's private repo You will now tag the image you created with the private repo's host name and port number, followed by the namespace you are using, as follows. docker tag marbles-$team:latest wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Log into the docker private registry using your teamNN id and credential, as follows: echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $team --password-stdin Sample Output: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded Now push up the image using the tag you just created (again be mindful that the name pushed in the output will reflect your team name): docker push wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Sample Output: The push refers to repository [wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00] c8490573a0d8: Pushed 8e63f87572fb: Pushed a6a08bb664f7: Pushed 3a30ca7a2471: Pushed ccc0f617b78a: Pushed 1801fc515e2a: Pushed 1.0: digest: sha256:6a796e973817f714b64e767b3c35affd93a6dc5df7ef12ca872aca64d20a5155 size: 1997 Let's log in to the ICP Console for the first time and verify that your image got pushed up to the cluster's private docker registry. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self-signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab: you can find this by echoing the team and credential variables in your terminal: echo $team echo $credential . Your team is your username and your credential is your password. You can verify your image got pushed up by going to the hamburger menu on the top left corner and selecting Container Images and look for lab-test/marbles-teamNN. Note: you will have to go to the last page to see images under the namespace lab-test. Create a Kubernetes deployment and service Log in to the ICP cluster with your team's ID and password: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Verify that your organization's Fabric pods are running. Note that you have a Fabric CA pod and one Fabric peer pod running. The environment variable $CORE_PEER_LOCALMSPID was set for you and it was set to your peer's MSPID. In this lab environment, your MSPID corresponds to your team number. i.e. team01 will be org1, team02 will be org2, etc. kubectl get pods | grep connectathon-$CORE_PEER_LOCALMSPID Sample Output: connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-xgqkb 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-fhz2f 2/2 Running 0 7h You should have a Kubernetes deployment yaml file in your /home/marbles directory called marbles-teamNN.yaml . Kubernetes objects are defined in yaml files and then created on or applied to a running cluster. You can create a Kubernetes resource from the ICP Console as well. But here you will do this via the command line tool kubectl which interacts with the Kubernetes API Server on the cluster. Now run the following command to create a marbles deployment yaml file that matches your team name. cat marbles-teamNN.yaml | sed -r 's/teamNN/'$team'/' marbles-$team.yaml You can cat the yaml file to see its contents: cat marbles-$team.yaml Sample Output: apiVersion: v1 kind: Service metadata: name: marbles-team00-svc spec: selector: app: marbles-team00 ports: - protocol: TCP port: 3001 targetPort: 3001 type: NodePort --- apiVersion: extensions/v1beta1 kind: Deployment metadata: name: marbles-team00-deploy labels: app: marbles-team00 spec: selector: matchLabels: app: marbles-team00 replicas: 1 template: metadata: labels: app: marbles-team00 spec: containers: - name: marbles-team00 image: wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 ports: - containerPort: 3001 imagePullPolicy: Always The important parts to point out in the yaml file are that it will create a Kubernetes service called marbles-team00-svc and that it is pointing to the marbles-team00 container. The service will be of type NodePort which means this service will be reachable outside of the cluster. The yaml file will also create a Kubernetes deployment that has one pod with one container that will be based off of the wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 image that you pushed to the private registry earlier. Deploy the service and test the Marbles UI Now you are ready to create the Kubernetes resources. Run the following command: kubectl apply -f marbles-$team.yaml service/marbles-team00-svc created deployment.extensions/marbles-team00-deploy created The deployment will create one pod that has one container. A service is also created. Check that your pod is READY 1/1 and in Running status: kubectl get pods | grep marbles-$team marbles-team00-deploy-55649dbc5b-xf787 1/1 Running 0 35s Launch the Marbles service and test the Marbles UI Now, let's navigate through the ICP Console to your deployment. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab. Go to the hamburger menu on the upper left corner, and select Workloads - Deployments . Find your team's deployment, it should be similar to marbles-team00-deploy but with your team name. Click on your deployment. You will be taken to the details page of your deployment. Upon further exploration you will see the deployment has one ReplicaSet, and one Pod. You can choose to click into either the ReplicaSet or Pod to get details about those two objects. Now click on the Launch button for your deployment. This will bring up the Marbles UI. At this point, depending on where the other classroom students are, you will see two or more organizations in the Marbles UI. Test out the application by transacting some marbles with your neighboring students. Enabling Story Mode in Settings will provide a step by step guided experience during each transaction. Congratulations! You've successfully created a container for the Marbles front end application, created a Kubernetes deployment for it, and deployed it in a IBM Cloud Private Kubernetes cluster.","title":"Part 2"},{"location":"connect-part2/#overview","text":"The goal of this part of the lab is to guide you through the process of packaging up a blockchain front end application to run inside a Kubernetes cluster. In the lab environment, this happens to be the same cluster that is hosting your blockchain components. In the real world, this may not always be the case. In this part of the lab, you will: Build a docker image with the Marbles UI Test the container locally on your Linux image Push the image to the ICP cluster's private docker registry Create a Kubernetes deployment and service for the Marbles UI Deploy the Kubernetes deployment Test the marbles UI","title":"Overview"},{"location":"connect-part2/#only-if-you-stopped-in-between-the-lab-parts-1-and-2","text":"make sure you still have an ssh connection to your bcuser instance. If not please rerun IP_ADDRESS=givenip for your given ip and ssh bcuser@$IP_ADDRESS Check to make sure you are still in your docker image. If you got out of your docker image go back into the image by first setting your TEAM with TEAM=teamxx where xx is the number of your team. Then, check if your container is still running with docker ps | grep team a) If you get sample output showing a container such as: 6e6ad92499b1 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-team10:1.0 \"bash\" 12 minutes ago Up 12 minutes 0.0.0.0:3000- 3001/tcp team10 follow Option a) of step 3 below b) If you get sample output not showing anything such as: follow Option b) of step 3 below Do only 1 of the options below based on step 2 above! a) exec back into your running container with docker exec -it $TEAM sh OR b) restart your container with docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock --name $TEAM -p 3000:3001 wsc-ibp-icp-cluster.icp:8500/lab-test/connectathon-s390x-$TEAM:1.0 bash","title":"Only if you stopped in between the lab parts 1 and 2"},{"location":"connect-part2/#before-you-start-make-sure-you-are-still-logged-in-to-the-cluster","text":"Run the following commands to display the pods that are currently deployed to our cluster. First, type kubectl get pods Sample Output: NAME READY STATUS RESTARTS AGE connectathon-orderer-orderer-85bb44f87c-qk662 1/1 Running 0 1d connectathon-ordererorg-ca-fabric-ca-deployment-7f6b9b6577whxgr 1/1 Running 0 1d connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 1d connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 1d connectathon-org1-ca-fabric-ca-deployment-59f9457fc5-9jmfp 1/1 Running 0 1d connectathon-org10-ca-fabric-ca-deployment-76794dcbbf-jdkcr 1/1 Running 0 1d connectathon-org10peer1-86dc5fcdf7-6c5qm 2/2 Running 0 39m connectathon-org11-ca-fabric-ca-deployment-5bc55cc776-5cjbz 1/1 Running 0 1d connectathon-org11peer1-69f67d965-svwjh 2/2 Running 0 1d connectathon-org1peer1-7665b7c6d7-x8spx 2/2 Running 0 1d connectathon-org2-ca-fabric-ca-deployment-787cbdf766-qwdjw 1/1 Running 0 1d connectathon-org2peer1-7d4bbfc7bf-gs9qv 2/2 Running 0 1d connectathon-org3-ca-fabric-ca-deployment-54cfc78777-m782f 1/1 Running 0 1d If you are able to see the output of the kubectl command such as above you are still logged in. If not, run: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Now, run kubectl get pods | grep $CORE_PEER_LOCALMSPID Sample Output: NAME READY STATUS RESTARTS AGE connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-9wtg7 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-5qncl 2/2 Running 0 7h You should see one peer pod, and one CA pod. Both should be in Running status. Your organization only has one peer in this scenario.","title":"Before you start, make sure you are still logged in to the cluster."},{"location":"connect-part2/#build-a-docker-image","text":"Now that you have tested the Marbles front end User Interface (Marbles UI, for short), let's save it as a docker image using the supplied Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Think of it as a specific way to package up a set of files and instructions that together make up a microservice. Go to your marbles directory: cd /home/marbles Here you should see a Dockerfile: ls -ltr Dockerfile Sample Output: -rw-rw-r-- 1 1000 1000 394 Feb 28 22:12 Dockerfile If you are curious, cat the file to look at its contents: cat Dockerfile Sample Output: FROM node:8-alpine ENV NPM_CONFIG_LOGLEVEL warn RUN mkdir -p /usr/src/app WORKDIR /usr/src/app COPY package.json /usr/src/app/ RUN apk add --no-cache --virtual .build-deps make gcc g++ python \\ npm install --silent \\ npm install gulp -g ---unsafe-perm \\ apk del .build-deps .build-deps make gcc g++ python COPY . /usr/src/app/ EXPOSE 3001 CMD [ gulp , marbles_tls ] The above Dockerfile builds from an Alpine node image already out there in DockerHub. This is a bare bones Linux image of the Alpine distribution with node version 8 installed. Next, the NPM_CONFIG_LOGLEVEL for npm is globally set to warn so that npm will only print errors and warnings. ENV is used for this to persist this change as an environment variable in your finished container. Then, it uses RUN to run a command inside of the base node:8-alpine container to make a directory for the marbles application. WORKDIR makes this directory the current working directory. Moreover, COPY brings the package.json file (containing the names of the application's dependent node modules) into the containers /usr/src/app directory. The following RUN command uses apk (Alpine's package manager) to install a variety of pre-reqs to your npm install such as make, gcc and python, before running the actual npm install twice to install both the necessary node modules needed by the Marbles UI itself and gulp to start the marbles UI. Note that this is all done in one line with to make it occur in one layer. This way, at the end of the RUN you can use a delete command apk del and take the developer tools you no longer need out of your image. If you instead ran this as multiple commands, you would not be able to shrink your image size since previous layers can't be effectively deleted due to the layered file system. Finally, you copy the application itself and the connection profile materials into your working directory, document the port you will run marbles on ( 3001 ), and set a command for the container to run when it starts gulp marbles_tls . Now let's run docker build in the /home/marbles directory: docker build -t marbles-$team . NOTE: Please remember to not forget that pesky . Otherwise you will get an error saying \"docker build\" requires exactly 1 argument Sample Output: Sending build context to Docker daemon 261.9MB Step 1/9 : FROM node:8-alpine --- 66f08ecb7600 Step 2/9 : ENV NPM_CONFIG_LOGLEVEL warn --- Using cache --- 180c28267c41 Step 3/9 : RUN mkdir -p /usr/src/app --- Using cache --- f9615b4a1813 Step 4/9 : WORKDIR /usr/src/app --- Using cache --- e53d507c2bf9 .... .... lots more messages .... Successfully built 9b57c7c3e480 Successfully tagged marbles-team00:latest Now you should see this new image that you just built: docker images Sample Output:","title":"Build a docker image"},{"location":"connect-part2/#test-the-docker-image-locally","text":"Let's test the image that was just built, by running it locally: docker run -it --init -p 3001:3001/tcp --name marbles-$team marbles-$team Sample Output [20:57:50] Using gulpfile /usr/src/app/gulpfile.js [20:57:50] Starting 'env_tls'... [20:57:50] Finished 'env_tls' after 73 \u03bcs [20:57:50] Starting 'build-sass'... [20:57:50] Finished 'build-sass' after 7.48 ms [20:57:50] Starting 'watch-sass'... [20:57:50] Finished 'watch-sass' after 7.47 ms [20:57:50] Starting 'watch-server'... [20:57:50] Finished 'watch-server' after 2.55 ms [20:57:50] Starting 'server'... info: Checking connection profile is done info: Loaded config file /usr/src/app/config/marbles_tls.json info: Loaded connection profile file /usr/src/app/config/connection_profile_tls.json ... lots of output ... - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - debug: Detected that we have launched successfully before debug: Welcome back - Marbles is ready debug: Open your browser to http://localhost:3001 and login as admin - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - After you see the \"Open your browser to https://localhost:3001\" message, point your browser to the IP address of your Linux image, e.g., http://192.168.22.107:3001 and you will see the Marbles UI. Once you verify that the image works locally, it's time to stop the running container. Type Ctrl + C to exit out of the running container in the current terminal.","title":"Test the docker image locally"},{"location":"connect-part2/#push-image-to-the-icp-clusters-private-repo","text":"You will now tag the image you created with the private repo's host name and port number, followed by the namespace you are using, as follows. docker tag marbles-$team:latest wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Log into the docker private registry using your teamNN id and credential, as follows: echo $credential | docker login wsc-ibp-icp-cluster.icp:8500 -u $team --password-stdin Sample Output: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded Now push up the image using the tag you just created (again be mindful that the name pushed in the output will reflect your team name): docker push wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-$team:1.0 Sample Output: The push refers to repository [wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00] c8490573a0d8: Pushed 8e63f87572fb: Pushed a6a08bb664f7: Pushed 3a30ca7a2471: Pushed ccc0f617b78a: Pushed 1801fc515e2a: Pushed 1.0: digest: sha256:6a796e973817f714b64e767b3c35affd93a6dc5df7ef12ca872aca64d20a5155 size: 1997 Let's log in to the ICP Console for the first time and verify that your image got pushed up to the cluster's private docker registry. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self-signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab: you can find this by echoing the team and credential variables in your terminal: echo $team echo $credential . Your team is your username and your credential is your password. You can verify your image got pushed up by going to the hamburger menu on the top left corner and selecting Container Images and look for lab-test/marbles-teamNN. Note: you will have to go to the last page to see images under the namespace lab-test.","title":"Push image to the ICP Cluster's private repo"},{"location":"connect-part2/#create-a-kubernetes-deployment-and-service","text":"Log in to the ICP cluster with your team's ID and password: cloudctl login -a https://192.168.22.81:8443 -u $team -p $credential -n lab-test Sample Output: Targeted account wsc-ibp-icp-cluster Account (id-wsc-ibp-icp-cluster-account) Targeted namespace lab-test Configuring kubectl ... Property clusters.wsc-ibp-icp-cluster unset. Property users.wsc-ibp-icp-cluster-user unset. Property contexts.wsc-ibp-icp-cluster-context unset. Cluster wsc-ibp-icp-cluster set. User wsc-ibp-icp-cluster-user set. Context wsc-ibp-icp-cluster-context created. Switched to context wsc-ibp-icp-cluster-context . OK Configuring helm: /root/.helm OK Verify that your organization's Fabric pods are running. Note that you have a Fabric CA pod and one Fabric peer pod running. The environment variable $CORE_PEER_LOCALMSPID was set for you and it was set to your peer's MSPID. In this lab environment, your MSPID corresponds to your team number. i.e. team01 will be org1, team02 will be org2, etc. kubectl get pods | grep connectathon-$CORE_PEER_LOCALMSPID Sample Output: connectathon-org0-ca-fabric-ca-deployment-67cf7486dd-xgqkb 1/1 Running 0 7h connectathon-org0peer1-55fc894b9-fhz2f 2/2 Running 0 7h You should have a Kubernetes deployment yaml file in your /home/marbles directory called marbles-teamNN.yaml . Kubernetes objects are defined in yaml files and then created on or applied to a running cluster. You can create a Kubernetes resource from the ICP Console as well. But here you will do this via the command line tool kubectl which interacts with the Kubernetes API Server on the cluster. Now run the following command to create a marbles deployment yaml file that matches your team name. cat marbles-teamNN.yaml | sed -r 's/teamNN/'$team'/' marbles-$team.yaml You can cat the yaml file to see its contents: cat marbles-$team.yaml Sample Output: apiVersion: v1 kind: Service metadata: name: marbles-team00-svc spec: selector: app: marbles-team00 ports: - protocol: TCP port: 3001 targetPort: 3001 type: NodePort --- apiVersion: extensions/v1beta1 kind: Deployment metadata: name: marbles-team00-deploy labels: app: marbles-team00 spec: selector: matchLabels: app: marbles-team00 replicas: 1 template: metadata: labels: app: marbles-team00 spec: containers: - name: marbles-team00 image: wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 ports: - containerPort: 3001 imagePullPolicy: Always The important parts to point out in the yaml file are that it will create a Kubernetes service called marbles-team00-svc and that it is pointing to the marbles-team00 container. The service will be of type NodePort which means this service will be reachable outside of the cluster. The yaml file will also create a Kubernetes deployment that has one pod with one container that will be based off of the wsc-ibp-icp-cluster.icp:8500/lab-test/marbles-team00:1.0 image that you pushed to the private registry earlier.","title":"Create a Kubernetes deployment and service"},{"location":"connect-part2/#deploy-the-service-and-test-the-marbles-ui","text":"Now you are ready to create the Kubernetes resources. Run the following command: kubectl apply -f marbles-$team.yaml service/marbles-team00-svc created deployment.extensions/marbles-team00-deploy created The deployment will create one pod that has one container. A service is also created. Check that your pod is READY 1/1 and in Running status: kubectl get pods | grep marbles-$team marbles-team00-deploy-55649dbc5b-xf787 1/1 Running 0 35s","title":"Deploy the service and test the Marbles UI"},{"location":"connect-part2/#launch-the-marbles-service-and-test-the-marbles-ui","text":"Now, let's navigate through the ICP Console to your deployment. Point your browser to https://192.168.22.81:8443 . Accept that it's using a self signed certificate. This should lead you to the sign in page. Log in with your team's credentials given to you at the beginning of the lab. Go to the hamburger menu on the upper left corner, and select Workloads - Deployments . Find your team's deployment, it should be similar to marbles-team00-deploy but with your team name. Click on your deployment. You will be taken to the details page of your deployment. Upon further exploration you will see the deployment has one ReplicaSet, and one Pod. You can choose to click into either the ReplicaSet or Pod to get details about those two objects. Now click on the Launch button for your deployment. This will bring up the Marbles UI. At this point, depending on where the other classroom students are, you will see two or more organizations in the Marbles UI. Test out the application by transacting some marbles with your neighboring students. Enabling Story Mode in Settings will provide a step by step guided experience during each transaction. Congratulations! You've successfully created a container for the Marbles front end application, created a Kubernetes deployment for it, and deployed it in a IBM Cloud Private Kubernetes cluster.","title":"Launch the Marbles service and test the Marbles UI"},{"location":"hlf/","text":"Welcome to the Hyperledger Fabric Lab --- Barry","title":"Lab"},{"location":"hlf/#welcome-to-the-hyperledger-fabric-lab-barry","text":"","title":"Welcome to the Hyperledger Fabric Lab --- Barry"},{"location":"vscode-home/","text":"Welcome to the VSCode Lab -- Austin","title":"Introduction"},{"location":"vscode-home/#welcome-to-the-vscode-lab-austin","text":"","title":"Welcome to the VSCode Lab -- Austin"}]}